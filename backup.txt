package proxy

import (
	`net`
	`log`
	"bufio"
	"regexp"
	"strings"
	"fmt"
	"io"
	"bytes"
)


// used to counting handled connections
var incoming = make(chan struct{}, 1000)
var leaving = make(chan struct{}, 1000)

// used to send signal to other goroutines to stop there work
var stop = make(chan struct{})


type Proxy struct {
	port string
	upstream string
	reverse string
	enableBlackList bool
	enableStatistic bool
	enableAuth bool
}

func (p *Proxy) Start() {
	if p.port == "" {
		p.port = "8080"
	}

	listener, err := net.Listen("tcp", ":" + p.port)
	if err != nil {
		log.Fatal(err)
	}

	if p.enableStatistic {
		go p.connectionStatus()
	}

	if p.enableAuth {
		go cache()
		go authDaemon()
	}

	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Println(err)
			continue
		}

		select {
		case <- stop:
			break
		default:
		}

		incoming <- struct{}{}
		go p.handleConn(conn)
	}
}

func (p *Proxy) Stop() {
	close(stop)
}

func (p *Proxy) EnableBlackList() {
	p.enableBlackList = true
}

func (p *Proxy) handleConn(conn net.Conn) {
	if p.reverse != "" {
		// reverse proxy mode
		p.handleConnReverseMode(conn)
		return
	}

	if p.upstream != "" {
		// upstream proxy mode
		p.handleConnUpstreamMode(conn)
		return
	}

	p.handleConnPlain(conn)
}

func (p *Proxy) EnableAuth() {
	p.enableAuth = true
}

var proxyString = "HTTP/1.1 200 Connection established\r\nProxy-agent: GoSimpleProxy\r\n\r\n"

func (p *Proxy) handleConnPlain(client net.Conn) {
	defer func() {
		client.Close()
		leaving <- struct{}{}
	}()

	connections := make(map[string]net.Conn)

	// read the first line of the client request to determine the destination server to connect
	readerClient := bufio.NewReader(client)
	firstLine, err := readerClient.ReadString('\n')
	if err != nil {
		log.Printf("read first line, get error: %v", err)
		return
	}

	target, proto, domain, url, err := parseServer(firstLine)
	if err != nil {
		log.Println(err)
		return
	}
	log.Println("first coming request:", target, proto, domain, url)

	if p.enableAuth {
		// bypass access to auth daemon to avoid auth loop
		if proto == "http" && !queryCache(strings.Split(client.RemoteAddr().String(), ":")[0]) {
			discardRemainHeaders(readerClient)
			authRedirect(client, proto + "://" + url)
		}
	}

	if p.enableBlackList {
		if scanTaskBlackListMatch(domain, url) {
			discardRemainHeaders(readerClient)
			takeActionBlackList(client, proto + "://" + url)
			return
		}
	}

	// server, err := createServerConn(target)
	server, err := net.Dial("tcp", target)
	if err != nil {
		log.Println(err)
		return
	}
	connections[target] = server
	//defer server.Close()

	if proto == "https" {
		discardRemainHeaders(readerClient)
		// send 200 connection established
		io.WriteString(client, proxyString)
	} else {
		// send all request lines to server
		io.WriteString(server, firstLine)
		for {
			s, err := readerClient.ReadString('\n')
			if err != nil {
				log.Printf("http write string to server: %v", err)
				break
			}
			io.WriteString(server, s)
			if index := strings.Index(s, "\r\n"); index == 0 {
				break
			}
		}
	}

	// deliver server data to client
	handleEachServer := func(target string, s net.Conn) {
		defer s.Close()
		io.Copy(client, s)
		delete(connections, target)
		leaving <- struct{}{}
	}

	go handleEachServer(target, server)

	// used by client to signal all requests have been done
	done := make(chan struct{})
	go p.handleMoreRequest(proto, readerClient, client, server, connections, done)

	<- done

}

// get target host, proto, domain, url from client request
func parseServer(header string) (target, proto, domain, url string, err error) {
	fields := headerSplit.Split(header, 5)
	if len(fields) != 3 || !methods[strings.ToUpper(fields[0])] {
		err = fmt.Errorf("parseServer: not http(s) protocol: %s", header)
		return
	}

	if strings.ToUpper(fields[0]) == "CONNECT" {
		target = fields[1]
		proto = "https"
		domain = strings.Split(target, ":")[0]
		url = domain
	} else {
		target = strings.Split(strings.Split(fields[1], "://")[1], "/")[0]
		proto = "http"
		url = strings.Split(fields[1], "://")[1]
		if !strings.Contains(target, ":") {
			target += ":80"
		}
		domain = strings.Split(target, ":")[0]
	}
	return
}

func (p *Proxy) handleMoreRequest(proto string, rdClient *bufio.Reader, wrClient net.Conn, wrServer net.Conn, connPool map[string]net.Conn, done chan<- struct{}) {
	//this only works with http, as https is encrypt and can not see plain '\n'
	var currentConn = wrServer
	if proto == "http" {
		reqIdentify := []byte(" HTTP/1.")
		for {
			b, err := rdClient.ReadBytes('\n')
			if err != nil {
				log.Printf("read more request from client meets error: %v", err)
				if len(b) > 0 {
					// send last bytes
					currentConn.Write(b)
					log.Printf("last bytes of client request have been sent: %s", string(b))
				}
				break
			}
			if bytes.Index(b, reqIdentify) != -1 {
				log.Printf("client issues another request: \n%s\n", string(b))
				if p.enableBlackList {
					target, _, domain, url, err := parseServer(string(b))
					if err != nil {
						log.Printf("parse proto error: %v", err)
						break
					}
					if _, ok := connPool[target]; !ok {
						server, err := net.Dial("tcp", target)
						if err != nil {
							log.Printf("handleMoreRequests, create new server conn: %v", err)
							break
						}
						connPool[target] = server
						incoming <- struct{}{}
					}
					// go handleEachConn
					currentConn = connPool[target]
					log.Printf("handleMoreRequest: checking blacklist match for: %s\n", url)
					if scanTaskBlackListMatch(domain, url) {
						log.Printf("matched blacklist item: %s", url)
						discardRemainHeaders(rdClient)
						takeActionBlackList(wrClient, proto + "://" + url)
						break
					}
					handleEachServer := func(target string, s net.Conn) {
						defer s.Close()
						io.Copy(wrClient, s)
						delete(connPool, target)
						leaving <- struct{}{}
					}
					go handleEachServer(target, currentConn)
				}
			}
			currentConn.Write(b)
		}
	} else {
		rdClient.WriteTo(wrServer)
	}

	close(done)
}

func discardRemainHeaders(rd *bufio.Reader) {
	identify := []byte("\r\n")
	for {
		s, err := rd.ReadBytes('\n')
		if err != nil {
			return
		}
		if bytes.Index(s, identify) == 0 {
			break
		}
	}
}